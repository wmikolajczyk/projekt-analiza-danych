---
title: "Projekt analiza danych"
author: "Wojciech Mikołajczyk"
date: "December 2, 2017"
output: 
  github_document:
    toc: true
    hard_line_breaks: false
---

### TODO: podsumowanie analizy

### Wykorzystane biblioteki
```{r load libraries, message=FALSE}
library(dplyr)
library(ggplot2)
library(reshape2)
library(caret)
```
dplyr - do przetwarzania dataframe  
ggplot2 - wykresy  
reshape2 - funkcja melt  
caret - regresor  

#### Wczytanie danych z pliku .csv
```{r load data, cache=TRUE}
power_stations <- read.csv('elektrownie.csv')
```

### Podsumowanie danych w zbiorze
#### 1. Rozmiar zbioru danych  
```{r dimensions}
dimensions <- dim(power_stations)
names(dimensions) <- c('l. wierszy', 'l. kolumn')
dimensions
```
Zbiór danych opisany jest 51 atrybutami i składa się z 235790 wierszy  

#### 2. Podstawowe statystyki  
```{r short datasummary}
summary(power_stations)
```
Prawie wszystkie wartości są wartościami liczbowymi, znormalizowanymi  

#### 3. Sprawdzenie czy zbiór zawiera wartości NA  
```{r check NA}
any(is.na(power_stations))
```
Zbiór nie zawiera wartości NA, zatem nie będzie konieczne zwracanie na ich wystąpienie uwagi przy przetwarzaniu  

#### 4. Typy kolumn  
```{r column types}
sapply(power_stations, class)
```
Prawie wszystkie typy wartości określone są jako 'numeric'. W przypadku 'data' przydałaby się zamiana typu. Część wartości zakwalifikowanych jako 'numeric' tak naprawdę jest typu 'factor' (np. idmodel - określający model ogniwa)  

#### 5. Liczba różnych wartości w kolumnach  
```{r unique values in columns, fig.width=9, fig.height=9}
sapply(power_stations, function(x) length(unique(x)))
ggplot(melt(lapply(power_stations[, !(names(power_stations) %in% c('id', 'data'))], function(x) length(unique(x)))), aes(x=L1, y=value)) + 
  geom_bar(stat = "identity") +
  labs(title = "Liczba różnych wartości", x = "Atrybut", y = "Liczba wartości") + 
  theme_bw() +
  theme(axis.text.x = element_text(angle = 70, size = 8, vjust = 1, hjust = 1))
```


#### 6. Rozkład wartości poszczególnych atrybutów  
```{r fig.width=9, fig.height=18, cache=TRUE}
ggplot(data = melt(power_stations), mapping = aes(x = value)) + 
  geom_histogram(bins=50) + 
  labs(title = "Rozkład wartości atrybutów") + 
  facet_wrap(~variable, ncol=4, scales = 'free_x') + 
  scale_x_continuous(labels = scales::comma) + 
  theme_bw()
```

#### 7. Liczba wartości 0 w kolumnach  
```{r count zeros}
sapply(power_stations, function(x) sum(x==0))
```

### Opis danych
Dane pochodzą z ogniw fotowoltaicznych umieszczonych we Włoszech. Opisane są przy użyciu 51 atrybutów, z czego część ma nazwy angielskie, część włoskie, a kilka z nich opisana jest skrótami.  
Wszystkie kolumny poza 'id', 'data' oraz 'anno' mają wartości liczbowe i są znormalizowane.
  
Interpretacja kolumn:  
id - identyfikator  
idsito - id ogniwa fotowoltaicznego  
idmodel - id modelu ogniwa fotowoltaicznego  
idbrand - id marki ogniwa fotowoltaicznego  
lat - szerokość geograficzna ogniwa fotowoltaicznego  
lon - długość geograficzna ogniwa fotowoltaicznego  
ageinmonths - wiek ogniwa fotowoltaicznego  
anno - rok  
day - dzien (przyjmuje 365 różnych wartości, więc wszystko się zgadza)  
ora - godzina (0 dla godz. 2:00, rośnie do 1 dla godz 20:00 czyli końca pomiarów)
data - data i czas w formacie MM/DD/YYYY HH:MM, od 1/2/2012 2:00 do 12/31/2013 20:00   
temperatura_ambiente - temperatura otoczenia, prawdopodobnie będzie wpływać na ilość wytwarzanej energii   
irradiamento - promieniowanie, prawdopodobnie będzie wpływać na ilość wytwarzanej energii
pressure - ciśnienie  
windspeed - prędkość wiatru   
humidity - wilgotność  
icon - ikona ?  
dewpoint - temperatura punktu rosy   
windbearing - łożysko wiatrowe ?   
cloud cover - zachmurzenie  
Nazwy kolumn tempi -> cloudcoveri odpowiadają kolumnom temperatura_ambiente -> cloudcover, trudno stwierdzić w jaki sposób ich wartości są powiązane  
dist - distance ?  
altitude - wysokość  
azimuth - azymut  
altitudei -> azimuthi - odpowiedniki włoskie altitude i azimuth - inne wartości  
pcnm1 -> pcnm15 - prawdopodobnie pomiary z jakichś czujników, mają tyle samo zer ile 'idsito' i 'idmodel' (wyjątkiem jest pcnm13) co może wskazywać że są powiązane z ogniwami fotowoltaicznymi - odpowiednim ogniwom odpowiadają powtarzające się wartości  
irr_pvgis_mod - ?  
irri_pvgis_mod - ?  
kwh - wytworzone Kilowatogodziny (wartości znormalizowane)  

Na podstawie tego, że dla każdej godziny jest 17 pomiarów, można wywnioskować, że pomiary pochodzą właśnie z 17 jednostek fotowoltaicznych. 
Pierwsze kolumny opisują ogniwa ('idsito', 'idmodel', 'idbrand', 'lat', 'lon', 'ageinmonths').

Wartości zerowe  
irradiamento - mogą być (noc)  
pressure - nie powinno być, chyba, że kodowanie? 

### Przygotowanie danych
#### 1. Poprawienie klas kolumn
```{r fix column types}
# to factor
# correlations doesn't work with not numeric
# change_to_factor <- c('idsito', 'idmodel', 'idbrand', 'anno', 'day')
# power_stations[, change_to_factor] <- lapply(power_stations[, change_to_factor], as.factor)
# to date
power_stations_for_cor <- power_stations
power_stations_for_cor$data <- as.numeric(as.POSIXlt(power_stations$data, format="%m/%d/%Y %H:%M"))
```
#### 2. Uzupełnienie brakujących wartości
```{r fix values}
# pressure
power_stations$pressure <- ifelse(power_stations$pressure == 0, mean(power_stations$pressure), power_stations$pressure)
power_stations$irradiamento <- ifelse(power_stations$irradiamento == 0 & power_stations$kwh != 0, mean(power_stations$irradiamento), power_stations$irradiamento)
```

### Korelacja zmiennych
#### 1. Wykres korelacji między zmiennymi
```{r fig.width=9, fig.height=9, cache=TRUE}
correlations <- round(cor(power_stations_for_cor), 2)
correlations[upper.tri(correlations)] <- NA
correlations_melt <- melt(correlations, na.rm = TRUE)

ggplot(data = correlations_melt, aes(Var1, Var2, fill = value)) + 
  geom_tile(color = "white") + 
  labs(title = "Korelacja atrybutów", x = "Atrybuty", y = "Wartość korelacji") + 
  scale_fill_gradient2(low="blue", mid="white", high="red", midpoint=0, limit=c(-1,1)) + 
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 70, size = 8, vjust = 1, hjust = 1)) +
  coord_fixed()
```

#### 2. Wykres korelacji między zmiennymi dla wartości bezwzględnej korelacji > 0.5 z pominięciem korelacji zmiennej względem samej siebie
```{r fig.width=9, fig.height=9, cache=TRUE}
top_correlatinons <- correlations_melt %>% filter(abs(value) > 0.5, Var1 != Var2)
ggplot(data = top_correlatinons, aes(Var1, Var2, fill = value)) + 
  geom_tile(color = "white") + 
  labs(title = "Korelacja atrybutów powyżej progu korelacji", x = "Atrybuty", y = "Wartość korelacji") + 
  scale_fill_gradient2(low="blue", mid="white", high="red", midpoint=0, limit=c(-1,1)) + 
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 70, size = 8, vjust = 1, hjust = 1)) +
  coord_fixed()
```

#### 3. Wykres korelacji atrybutów do kwh
```{r fig.width=9, fig.height=9, cache=TRUE}
kwh_correlations <- melt(correlations['kwh', ])
ggplot(data = kwh_correlations, mapping = aes(x=rownames(kwh_correlations), y=value)) + 
  geom_bar(stat="identity") + 
  labs(title = "Korelacja do atrybutu kwh", x = "Atrybuty", y = "Wartość korelacji") + 
  coord_flip() + 
  theme_bw()
```

### Wykres - zmiana wytwarzanej energii przez ogniwa w czasie i przestrzeni
```{r fig.width=9, fig.height=9, cache=TRUE}
power_stations <- power_stations %>% mutate(date_year_month=format(as.POSIXct(data, format='%m/%d/%Y %H:%M'), "%Y-%m"))
energy_sito_date <- power_stations %>% group_by(date_year_month, idsito) %>% summarise(sum_kwh=sum(kwh))
ggplot(data = energy_sito_date, mapping = aes(x=date_year_month, y=sum_kwh, color=factor(idsito), group=factor(idsito))) + 
  geom_line() +
  labs(title = "Wykres energii w czasie dla ogniw", x = "Data", y = "Suma wytworzonej energii[kwh]") +
  theme(axis.text.x = element_text(angle = 70, size = 8, vjust = 1, hjust = 1))
```

### Regresor
```{r regressor, cache=TRUE}
power_stations_sample <- power_stations %>% select(idsito, irradiamento, irr_pvgis_mod, altitude, irri, tempi, kwh)
set.seed(93)
inTraining <- 
    createDataPartition(
        y = power_stations_sample$idsito,
        p = .85,
        list = FALSE)

training <- power_stations_sample[ inTraining,]
testing  <- power_stations_sample[-inTraining,]

ctrl <- trainControl(
    method = "repeatedcv",
    number = 2,
    repeats = 2)

set.seed(93)
fit <- train(kwh ~ .,
             data = training,
             method = "rf",
             trControl = ctrl,
             ntree = 25)
fit
my_pred <- predict(fit, newdata = testing)

defaultSummary(data.frame(pred = my_pred, obs = testing$kwh))
```
